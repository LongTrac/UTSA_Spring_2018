; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	d:\__data\vault\_schoolwork\2017 01 cs 3843 computer organization\programs\helloage4\helloage\Inline.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	_exit:PROC
$SG-295	DB	0aH, 00H
	ORG $+2
$SG-296	DB	'%02X ', 00H
	ORG $+2
$SG-297	DB	0aH, 0aH, 00H
	ORG $+1
$SG-298	DB	09H, 'C', 09H, 'Z', 09H, 'Y', 09H, 'X', 0aH, 00H
	ORG $+2
$SG-299	DB	'---------------------------', 0aH, 00H
	ORG $+3
$SG-300	DB	'InA:', 09H, 09H, '%d', 09H, '%d', 09H, '%d', 0aH, 00H
$SG-301	DB	'InB:', 09H, 09H, '%d', 09H, '%d', 09H, '%d', 0aH, 00H
$SG-302	DB	'Out:', 09H, '%d', 09H, '%d', 09H, '%d', 09H, '%d', 0aH, 0aH
	DB	0aH, 00H
$SG-303	DB	'A=%d, B=%d, C=%d --> X=%d', 0aH, 00H
PUBLIC	?bitFieldExample@@YAXXZ				; bitFieldExample
; Function compile flags: /Odtp
; File d:\__data\vault\_schoolwork\2017 01 cs 3843 computer organization\programs\helloage4\helloage\inline.cpp
;	COMDAT ?bitFieldExample@@YAXXZ
_TEXT	SEGMENT
_out$ = -17						; size = 1
_carry$ = -16					; size = 4
_in$ = -12						; size = 2
_x$ = -8						; size = 4
_y$ = -4						; size = 4
?bitFieldExample@@YAXXZ PROC				; bitFieldExample, COMDAT

; 223  : {

  00000	55						push	 ebp
  00001	8b ec					mov	 ebp, esp
  00003	83 ec 14				sub	 esp, 20			; 00000014H

; 224  : 	unsigned int x, y, carry;
; 225  : 	BINARY_INPUT in[2], out;
; 226  : 
; 227  : 	for(x = 0; x < 2; x++)

  00006	c7 45 f8 00 00 00 00	mov	 DWORD PTR _x$[ebp], 0
  0000d	eb 09					jmp	 SHORT $LN28@bitFieldEx
$LN27@bitFieldEx:
  0000f	8b 45 f8				mov	 eax, DWORD PTR _x$[ebp]
  00012	83 c0 01				add	 eax, 1
  00015	89 45 f8				mov	 DWORD PTR _x$[ebp], eax
$LN28@bitFieldEx:
  00018	83 7d f8 02				cmp	 DWORD PTR _x$[ebp], 2
  0001c	73 64					jae	 SHORT $LN26@bitFieldEx

; 228  : 	{
; 229  : 		in[x].bit0 = 0;

  0001e	8b 4d f8				mov	 ecx, DWORD PTR _x$[ebp]
  00021	8a 54 0d f4				mov	 dl, BYTE PTR _in$[ebp+ecx]
  00025	80 e2 fe				and	 dl, 254			; 000000feH
  00028	8b 45 f8				mov	 eax, DWORD PTR _x$[ebp]
  0002b	88 54 05 f4				mov	 BYTE PTR _in$[ebp+eax], dl

; 230  : 		in[x].bit1 = 0;

  0002f	8b 4d f8				mov	 ecx, DWORD PTR _x$[ebp]
  00032	8a 54 0d f4				mov	 dl, BYTE PTR _in$[ebp+ecx]
  00036	80 e2 fd				and	 dl, 253			; 000000fdH
  00039	8b 45 f8				mov	 eax, DWORD PTR _x$[ebp]
  0003c	88 54 05 f4				mov	 BYTE PTR _in$[ebp+eax], dl

; 231  : 		in[x].bit2 = 0;

  00040	8b 4d f8				mov	 ecx, DWORD PTR _x$[ebp]
  00043	8a 54 0d f4				mov	 dl, BYTE PTR _in$[ebp+ecx]
  00047	80 e2 fb				and	 dl, 251			; 000000fbH
  0004a	8b 45 f8				mov	 eax, DWORD PTR _x$[ebp]
  0004d	88 54 05 f4				mov	 BYTE PTR _in$[ebp+eax], dl

; 232  : 		in[x].bit3 = 0;

  00051	8b 4d f8				mov	 ecx, DWORD PTR _x$[ebp]
  00054	8a 54 0d f4				mov	 dl, BYTE PTR _in$[ebp+ecx]
  00058	80 e2 f7				and	 dl, 247			; 000000f7H
  0005b	8b 45 f8				mov	 eax, DWORD PTR _x$[ebp]
  0005e	88 54 05 f4				mov	 BYTE PTR _in$[ebp+eax], dl

; 233  : 		in[x].bit4_7 = -5 + x;

  00062	8b 4d f8				mov	 ecx, DWORD PTR _x$[ebp]
  00065	83 e9 05				sub	 ecx, 5
  00068	80 e1 0f				and	 cl, 15			; 0000000fH
  0006b	c0 e1 04				shl	 cl, 4
  0006e	8b 55 f8				mov	 edx, DWORD PTR _x$[ebp]
  00071	8a 44 15 f4				mov	 al, BYTE PTR _in$[ebp+edx]
  00075	24 0f					and	 al, 15			; 0000000fH
  00077	0a c1					or	 al, cl
  00079	8b 4d f8				mov	 ecx, DWORD PTR _x$[ebp]
  0007c	88 44 0d f4				mov	 BYTE PTR _in$[ebp+ecx], al

; 234  : 	}

  00080	eb 8d					jmp	 SHORT $LN27@bitFieldEx
$LN26@bitFieldEx:

; 235  : 
; 236  : 	for(x = 0; x < 8; x++)

  00082	c7 45 f8 00 00 00 00	mov	 DWORD PTR _x$[ebp], 0
  00089	eb 09					jmp	 SHORT $LN25@bitFieldEx
$LN24@bitFieldEx:
  0008b	8b 55 f8				mov	 edx, DWORD PTR _x$[ebp]
  0008e	83 c2 01				add	 edx, 1
  00091	89 55 f8				mov	 DWORD PTR _x$[ebp], edx
$LN25@bitFieldEx:
  00094	83 7d f8 08				cmp	 DWORD PTR _x$[ebp], 8
  00098	0f 83 3f 03 00 00		jae	 $LN29@bitFieldEx

; 237  : 	{
; 238  : 		carry = 0;

  0009e	c7 45 f0 00 00 00 00	mov	 DWORD PTR _carry$[ebp], 0

; 239  : 		out.bit0 = in[0].bit0 + in[1].bit0 + carry;

  000a5	8a 45 f4				mov	 al, BYTE PTR _in$[ebp]
  000a8	24 01					and	 al, 1
  000aa	0f b6 c8				movzx	 ecx, al
  000ad	8a 55 f5				mov	 dl, BYTE PTR _in$[ebp+1]
  000b0	80 e2 01				and	 dl, 1
  000b3	0f b6 c2				movzx	 eax, dl
  000b6	03 4d f0				add	 ecx, DWORD PTR _carry$[ebp]
  000b9	03 c1					add	 eax, ecx
  000bb	24 01					and	 al, 1
  000bd	8a 4d ef				mov	 cl, BYTE PTR _out$[ebp]
  000c0	80 e1 fe				and	 cl, 254			; 000000feH
  000c3	0a c8					or	 cl, al
  000c5	88 4d ef				mov	 BYTE PTR _out$[ebp], cl

; 240  : 		if(in[0].bit0 == 1 && in[1].bit0 == 1) carry = 1;

  000c8	8a 55 f4				mov	 dl, BYTE PTR _in$[ebp]
  000cb	80 e2 01				and	 dl, 1
  000ce	0f b6 c2				movzx	 eax, dl
  000d1	83 f8 01				cmp	 eax, 1
  000d4	75 15					jne	 SHORT $LN22@bitFieldEx
  000d6	8a 4d f5				mov	 cl, BYTE PTR _in$[ebp+1]
  000d9	80 e1 01				and	 cl, 1
  000dc	0f b6 d1				movzx	 edx, cl
  000df	83 fa 01				cmp	 edx, 1
  000e2	75 07					jne	 SHORT $LN22@bitFieldEx
  000e4	c7 45 f0 01 00 00 00	mov	 DWORD PTR _carry$[ebp], 1
$LN22@bitFieldEx:

; 241  : 		if( (in[0].bit0 == 1 && in[1].bit0 == 1) || (in[0].bit0 == 1 && carry == 1) || (in[1].bit0 == 1 && carry == 1) )

  000eb	8a 45 f4	 mov	 al, BYTE PTR _in$[ebp]
  000ee	24 01		 and	 al, 1
  000f0	0f b6 c8	 movzx	 ecx, al
  000f3	83 f9 01	 cmp	 ecx, 1
  000f6	75 0e		 jne	 SHORT $LN19@bitFieldEx
  000f8	8a 55 f5	 mov	 dl, BYTE PTR _in$[ebp+1]
  000fb	80 e2 01	 and	 dl, 1
  000fe	0f b6 c2	 movzx	 eax, dl
  00101	83 f8 01	 cmp	 eax, 1
  00104	74 27		 je		SHORT $LN20@bitFieldEx
$LN19@bitFieldEx:
  00106	8a 4d f4	 mov	 cl, BYTE PTR _in$[ebp]
  00109	80 e1 01	 and	 cl, 1
  0010c	0f b6 d1	 movzx	 edx, cl
  0010f	83 fa 01	 cmp	 edx, 1
  00112	75 06		 jne	 SHORT $LN18@bitFieldEx
  00114	83 7d f0 01	 cmp	 DWORD PTR _carry$[ebp], 1
  00118	74 13		 je		SHORT $LN20@bitFieldEx
$LN18@bitFieldEx:
  0011a	8a 45 f5	 mov	 al, BYTE PTR _in$[ebp+1]
  0011d	24 01		 and	 al, 1
  0011f	0f b6 c8	 movzx	 ecx, al
  00122	83 f9 01	 cmp	 ecx, 1
  00125	75 0f		 jne	 SHORT $LN21@bitFieldEx
  00127	83 7d f0 01	 cmp	 DWORD PTR _carry$[ebp], 1
  0012b	75 09		 jne	 SHORT $LN21@bitFieldEx
$LN20@bitFieldEx:

; 242  : 			carry = 1;

  0012d	c7 45 f0 01 00 00 00	mov	 DWORD PTR _carry$[ebp], 1

; 243  : 		else

  00134	eb 07					jmp	 SHORT $LN17@bitFieldEx
$LN21@bitFieldEx:

; 244  : 			carry = 0;

  00136	c7 45 f0 00 00 00 00	mov	 DWORD PTR _carry$[ebp], 0
$LN17@bitFieldEx:

; 245  : 
; 246  : 		out.bit1 = in[0].bit1 + in[1].bit1 + carry;

  0013d	8a 55 f4	 mov	 dl, BYTE PTR _in$[ebp]
  00140	d0 ea		 shr	 dl, 1
  00142	80 e2 01	 and	 dl, 1
  00145	0f b6 c2	 movzx	 eax, dl
  00148	8a 4d f5	 mov	 cl, BYTE PTR _in$[ebp+1]
  0014b	d0 e9		 shr	 cl, 1
  0014d	80 e1 01	 and	 cl, 1
  00150	0f b6 d1	 movzx	 edx, cl
  00153	03 45 f0	 add	 eax, DWORD PTR _carry$[ebp]
  00156	03 d0		 add	 edx, eax
  00158	80 e2 01	 and	 dl, 1
  0015b	d0 e2		 shl	 dl, 1
  0015d	8a 45 ef	 mov	 al, BYTE PTR _out$[ebp]
  00160	24 fd		 and	 al, 253			; 000000fdH
  00162	0a c2		 or		 al, dl
  00164	88 45 ef	 mov	 BYTE PTR _out$[ebp], al

; 247  : 		if( (in[0].bit1 == 1 && in[1].bit1 == 1) || (in[0].bit1 == 1 && carry == 1) || (in[1].bit1 == 1 && carry == 1) )

  00167	8a 4d f4	 mov	 cl, BYTE PTR _in$[ebp]
  0016a	d0 e9		 shr	 cl, 1
  0016c	80 e1 01	 and	 cl, 1
  0016f	0f b6 d1	 movzx	 edx, cl
  00172	83 fa 01	 cmp	 edx, 1
  00175	75 0f		 jne	 SHORT $LN14@bitFieldEx
  00177	8a 45 f5	 mov	 al, BYTE PTR _in$[ebp+1]
  0017a	d0 e8		 shr	 al, 1
  0017c	24 01		 and	 al, 1
  0017e	0f b6 c8	 movzx	 ecx, al
  00181	83 f9 01	 cmp	 ecx, 1
  00184	74 2c		 je	 SHORT $LN15@bitFieldEx
$LN14@bitFieldEx:
  00186	8a 55 f4	 mov	 dl, BYTE PTR _in$[ebp]
  00189	d0 ea		 shr	 dl, 1
  0018b	80 e2 01	 and	 dl, 1
  0018e	0f b6 c2	 movzx	 eax, dl
  00191	83 f8 01	 cmp	 eax, 1
  00194	75 06		 jne	 SHORT $LN13@bitFieldEx
  00196	83 7d f0 01	 cmp	 DWORD PTR _carry$[ebp], 1
  0019a	74 16		 je	 SHORT $LN15@bitFieldEx
$LN13@bitFieldEx:
  0019c	8a 4d f5	 mov	 cl, BYTE PTR _in$[ebp+1]
  0019f	d0 e9		 shr	 cl, 1
  001a1	80 e1 01	 and	 cl, 1
  001a4	0f b6 d1	 movzx	 edx, cl
  001a7	83 fa 01	 cmp	 edx, 1
  001aa	75 0f		 jne	 SHORT $LN16@bitFieldEx
  001ac	83 7d f0 01	 cmp	 DWORD PTR _carry$[ebp], 1
  001b0	75 09		 jne	 SHORT $LN16@bitFieldEx
$LN15@bitFieldEx:

; 248  : 			carry = 1;

  001b2	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _carry$[ebp], 1

; 249  : 		else

  001b9	eb 07		 jmp	 SHORT $LN12@bitFieldEx
$LN16@bitFieldEx:

; 250  : 			carry = 0;

  001bb	c7 45 f0 00 00 00 00		mov	 DWORD PTR _carry$[ebp], 0
$LN12@bitFieldEx:

; 251  : 
; 252  : 		out.bit2 = in[0].bit2 + in[1].bit2 + carry;

  001c2	8a 45 f4	 mov	 al, BYTE PTR _in$[ebp]
  001c5	c0 e8 02	 shr	 al, 2
  001c8	24 01		 and	 al, 1
  001ca	0f b6 c8	 movzx	 ecx, al
  001cd	8a 55 f5	 mov	 dl, BYTE PTR _in$[ebp+1]
  001d0	c0 ea 02	 shr	 dl, 2
  001d3	80 e2 01	 and	 dl, 1
  001d6	0f b6 c2	 movzx	 eax, dl
  001d9	03 4d f0	 add	 ecx, DWORD PTR _carry$[ebp]
  001dc	03 c1		 add	 eax, ecx
  001de	24 01		 and	 al, 1
  001e0	c0 e0 02	 shl	 al, 2
  001e3	8a 4d ef	 mov	 cl, BYTE PTR _out$[ebp]
  001e6	80 e1 fb	 and	 cl, 251			; 000000fbH
  001e9	0a c8		 or	 cl, al
  001eb	88 4d ef	 mov	 BYTE PTR _out$[ebp], cl

; 253  : 		if( (in[0].bit2 == 1 && in[1].bit2 == 1) || (in[0].bit2 == 1 && carry == 1) || (in[1].bit2 == 1 && carry == 1) )

  001ee	8a 55 f4	 mov	 dl, BYTE PTR _in$[ebp]
  001f1	c0 ea 02	 shr	 dl, 2
  001f4	80 e2 01	 and	 dl, 1
  001f7	0f b6 c2	 movzx	 eax, dl
  001fa	83 f8 01	 cmp	 eax, 1
  001fd	75 11		 jne	 SHORT $LN9@bitFieldEx
  001ff	8a 4d f5	 mov	 cl, BYTE PTR _in$[ebp+1]
  00202	c0 e9 02	 shr	 cl, 2
  00205	80 e1 01	 and	 cl, 1
  00208	0f b6 d1	 movzx	 edx, cl
  0020b	83 fa 01	 cmp	 edx, 1
  0020e	74 2d		 je	 SHORT $LN10@bitFieldEx
$LN9@bitFieldEx:
  00210	8a 45 f4	 mov	 al, BYTE PTR _in$[ebp]
  00213	c0 e8 02	 shr	 al, 2
  00216	24 01		 and	 al, 1
  00218	0f b6 c8	 movzx	 ecx, al
  0021b	83 f9 01	 cmp	 ecx, 1
  0021e	75 06		 jne	 SHORT $LN8@bitFieldEx
  00220	83 7d f0 01	 cmp	 DWORD PTR _carry$[ebp], 1
  00224	74 17		 je	 SHORT $LN10@bitFieldEx
$LN8@bitFieldEx:
  00226	8a 55 f5	 mov	 dl, BYTE PTR _in$[ebp+1]
  00229	c0 ea 02	 shr	 dl, 2
  0022c	80 e2 01	 and	 dl, 1
  0022f	0f b6 c2	 movzx	 eax, dl
  00232	83 f8 01	 cmp	 eax, 1
  00235	75 0f		 jne	 SHORT $LN11@bitFieldEx
  00237	83 7d f0 01	 cmp	 DWORD PTR _carry$[ebp], 1
  0023b	75 09		 jne	 SHORT $LN11@bitFieldEx
$LN10@bitFieldEx:

; 254  : 			carry = 1;

  0023d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _carry$[ebp], 1

; 255  : 		else

  00244	eb 07		 jmp	 SHORT $LN7@bitFieldEx
$LN11@bitFieldEx:

; 256  : 			carry = 0;

  00246	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _carry$[ebp], 0
$LN7@bitFieldEx:

; 257  : 
; 258  : 		printf("	C	Z	Y	X\n");

  0024d	68 00 00 00 00	 push	 OFFSET $SG-298
  00252	e8 00 00 00 00	 call	 _printf
  00257	83 c4 04	 add	 esp, 4

; 259  : 		printf("---------------------------\n");

  0025a	68 00 00 00 00	 push	 OFFSET $SG-299
  0025f	e8 00 00 00 00	 call	 _printf
  00264	83 c4 04		add	 esp, 4

; 260  : 		printf("InA:		%d	%d	%d\n", in[0].bit2, in[0].bit1, in[0].bit0);

  00267	8a 4d f4	 mov	 cl, BYTE PTR _in$[ebp]
  0026a	80 e1 01	 and	 cl, 1
  0026d	0f b6 d1	 movzx	 edx, cl
  00270	52		 push	 edx
  00271	8a 45 f4	 mov	 al, BYTE PTR _in$[ebp]
  00274	d0 e8		 shr	 al, 1
  00276	24 01		 and	 al, 1
  00278	0f b6 c8	 movzx	 ecx, al
  0027b	51		 push	 ecx
  0027c	8a 55 f4	 mov	 dl, BYTE PTR _in$[ebp]
  0027f	c0 ea 02	 shr	 dl, 2
  00282	80 e2 01	 and	 dl, 1
  00285	0f b6 c2	 movzx	 eax, dl
  00288	50		 push	 eax
  00289	68 00 00 00 00	 push	 OFFSET $SG-300
  0028e	e8 00 00 00 00	 call	 _printf
  00293	83 c4 10	 add	 esp, 16			; 00000010H

; 261  : 		printf("InB:		%d	%d	%d\n", in[1].bit2, in[1].bit1, in[1].bit0);

  00296	8a 4d f5	 mov	 cl, BYTE PTR _in$[ebp+1]
  00299	80 e1 01	 and	 cl, 1
  0029c	0f b6 d1	 movzx	 edx, cl
  0029f	52		 push	 edx
  002a0	8a 45 f5	 mov	 al, BYTE PTR _in$[ebp+1]
  002a3	d0 e8		 shr	 al, 1
  002a5	24 01		 and	 al, 1
  002a7	0f b6 c8	 movzx	 ecx, al
  002aa	51		 push	 ecx
  002ab	8a 55 f5	 mov	 dl, BYTE PTR _in$[ebp+1]
  002ae	c0 ea 02	 shr	 dl, 2
  002b1	80 e2 01	 and	 dl, 1
  002b4	0f b6 c2	 movzx	 eax, dl
  002b7	50		 push	 eax
  002b8	68 00 00 00 00	 push	 OFFSET $SG-301
  002bd	e8 00 00 00 00	 call	 _printf
  002c2	83 c4 10	 add	 esp, 16			; 00000010H

; 262  : 		printf("Out:	%d	%d	%d	%d\n\n\n", carry, out.bit2, out.bit1, out.bit0);

  002c5	8a 4d ef	 mov	 cl, BYTE PTR _out$[ebp]
  002c8	80 e1 01	 and	 cl, 1
  002cb	0f b6 d1	 movzx	 edx, cl
  002ce	52		 push	 edx
  002cf	8a 45 ef	 mov	 al, BYTE PTR _out$[ebp]
  002d2	d0 e8		 shr	 al, 1
  002d4	24 01		 and	 al, 1
  002d6	0f b6 c8	 movzx	 ecx, al
  002d9	51		 push	 ecx
  002da	8a 55 ef	 mov	 dl, BYTE PTR _out$[ebp]
  002dd	c0 ea 02	 shr	 dl, 2
  002e0	80 e2 01	 and	 dl, 1
  002e3	0f b6 c2	 movzx	 eax, dl
  002e6	50		 push	 eax
  002e7	8b 4d f0	 mov	 ecx, DWORD PTR _carry$[ebp]
  002ea	51		 push	 ecx
  002eb	68 00 00 00 00	 push	 OFFSET $SG-302
  002f0	e8 00 00 00 00	 call	 _printf
  002f5	83 c4 14	 add	 esp, 20			; 00000014H

; 263  : 
; 264  : 		for(y = 0; y < 2; y++)

  002f8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  002ff	eb 09		 jmp	 SHORT $LN6@bitFieldEx
$LN5@bitFieldEx:
  00301	8b 55 fc	 mov	 edx, DWORD PTR _y$[ebp]
  00304	83 c2 01	 add	 edx, 1
  00307	89 55 fc	 mov	 DWORD PTR _y$[ebp], edx
$LN6@bitFieldEx:
  0030a	83 7d fc 02	 cmp	 DWORD PTR _y$[ebp], 2
  0030e	0f 83 c4 00 00
	00		 jae	 $LN4@bitFieldEx

; 265  : 		{
; 266  : 			in[y].bit0 = in[y].bit0 + 1;

  00314	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  00317	8a 4c 05 f4	 mov	 cl, BYTE PTR _in$[ebp+eax]
  0031b	80 e1 01	 and	 cl, 1
  0031e	0f b6 d1	 movzx	 edx, cl
  00321	83 c2 01	 add	 edx, 1
  00324	80 e2 01	 and	 dl, 1
  00327	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  0032a	8a 4c 05 f4	 mov	 cl, BYTE PTR _in$[ebp+eax]
  0032e	80 e1 fe	 and	 cl, 254			; 000000feH
  00331	0a ca		 or	 cl, dl
  00333	8b 55 fc	 mov	 edx, DWORD PTR _y$[ebp]
  00336	88 4c 15 f4	 mov	 BYTE PTR _in$[ebp+edx], cl

; 267  : 			if(in[y].bit0 == 0) 

  0033a	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  0033d	8a 4c 05 f4	 mov	 cl, BYTE PTR _in$[ebp+eax]
  00341	80 e1 01	 and	 cl, 1
  00344	0f b6 d1	 movzx	 edx, cl
  00347	85 d2		 test	 edx, edx
  00349	0f 85 84 00 00
	00		 jne	 $LN3@bitFieldEx

; 268  : 			{
; 269  : 				in[y].bit1 = in[y].bit1 + 1;

  0034f	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  00352	8a 4c 05 f4	 mov	 cl, BYTE PTR _in$[ebp+eax]
  00356	d0 e9		 shr	 cl, 1
  00358	80 e1 01	 and	 cl, 1
  0035b	0f b6 d1	 movzx	 edx, cl
  0035e	83 c2 01	 add	 edx, 1
  00361	80 e2 01	 and	 dl, 1
  00364	d0 e2		 shl	 dl, 1
  00366	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  00369	8a 4c 05 f4	 mov	 cl, BYTE PTR _in$[ebp+eax]
  0036d	80 e1 fd	 and	 cl, 253			; 000000fdH
  00370	0a ca		 or	 cl, dl
  00372	8b 55 fc	 mov	 edx, DWORD PTR _y$[ebp]
  00375	88 4c 15 f4	 mov	 BYTE PTR _in$[ebp+edx], cl

; 270  : 				if(in[y].bit1 == 0)

  00379	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  0037c	8a 4c 05 f4	 mov	 cl, BYTE PTR _in$[ebp+eax]
  00380	d0 e9		 shr	 cl, 1
  00382	80 e1 01	 and	 cl, 1
  00385	0f b6 d1	 movzx	 edx, cl
  00388	85 d2		 test	 edx, edx
  0038a	75 47		 jne	 SHORT $LN3@bitFieldEx

; 271  : 				{
; 272  : 					in[y].bit2 = in[y].bit2 + 1;

  0038c	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  0038f	8a 4c 05 f4	 mov	 cl, BYTE PTR _in$[ebp+eax]
  00393	c0 e9 02	 shr	 cl, 2
  00396	80 e1 01	 and	 cl, 1
  00399	0f b6 d1	 movzx	 edx, cl
  0039c	83 c2 01	 add	 edx, 1
  0039f	80 e2 01	 and	 dl, 1
  003a2	c0 e2 02	 shl	 dl, 2
  003a5	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  003a8	8a 4c 05 f4	 mov	 cl, BYTE PTR _in$[ebp+eax]
  003ac	80 e1 fb	 and	 cl, 251			; 000000fbH
  003af	0a ca		 or	 cl, dl
  003b1	8b 55 fc	 mov	 edx, DWORD PTR _y$[ebp]
  003b4	88 4c 15 f4	 mov	 BYTE PTR _in$[ebp+edx], cl

; 273  : 					if(in[y].bit2 == 0)

  003b8	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  003bb	8a 4c 05 f4	 mov	 cl, BYTE PTR _in$[ebp+eax]
  003bf	c0 e9 02	 shr	 cl, 2
  003c2	80 e1 01	 and	 cl, 1
  003c5	0f b6 d1	 movzx	 edx, cl
  003c8	85 d2		 test	 edx, edx
  003ca	75 07		 jne	 SHORT $LN3@bitFieldEx

; 274  : 						carry = 1;

  003cc	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _carry$[ebp], 1
$LN3@bitFieldEx:

; 275  : 				}
; 276  : 			}
; 277  : 		}

  003d3	e9 29 ff ff ff	 jmp	 $LN5@bitFieldEx
$LN4@bitFieldEx:

; 278  : 	}

  003d8	e9 ae fc ff ff	 jmp	 $LN24@bitFieldEx
$LN29@bitFieldEx:

; 279  : 
; 280  : 	return;
; 281  : } // bitFieldExample

  003dd	8b e5		 mov	 esp, ebp
  003df	5d		 pop	 ebp
  003e0	c3		 ret	 0
?bitFieldExample@@YAXXZ ENDP				; bitFieldExample
PUBLIC	?callInLineFunctions@@YAXXZ			; callInLineFunctions
; Function compile flags: /Odtp
;	COMDAT ?callInLineFunctions@@YAXXZ
_TEXT	SEGMENT
?callInLineFunctions@@YAXXZ PROC			; callInLineFunctions, COMDAT

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 74 01 00
	00		 sub	 esp, 372		; 00000174H

; 285  : 	int x, tmpi;
; 286  : 	char dstA[32], srcA[64];	// no overlap
; 287  : 	char overlap[256], *ptrDstO, *ptrSrcO;
; 288  : 
; 289  : 	bitFieldExample();

  00009	e8 00 00 00 00	 call	 ?bitFieldExample@@YAXXZ	; bitFieldExample

; 290  : 
; 291  : /*
; 292  : 	memset(srcA, 0x90, 32);
; 293  : 	memset(srcA, 0x90, 32);
; 294  : 	strcpy(srcA, "Say goodbye!");
; 295  : 	inline_Strcpy(dstA, srcA, 32 );
; 296  : 	printf("--- srcA = %s\n", srcA);
; 297  : 	printBytes(srcA, 64);
; 298  : 	printf("dstA = %s\n", dstA);
; 299  : 	printBytes(dstA, 32);
; 300  : 
; 301  : 	strcpy(srcA, "Say hello to the lazy dog who ate my homework.");
; 302  : 	inline_Strcpy(dstA, srcA, 32 );
; 303  : 	printf("--- srcA = %s\n", srcA);
; 304  : 	printBytes(srcA, 64);
; 305  : 	printf("dstA = %s\n", dstA);
; 306  : 	printBytes(dstA, 32);
; 307  : 
; 308  : 	strcpy(srcA, "This is so much fun I could.2932");
; 309  : 	inline_Strcpy(dstA, srcA, 32 );
; 310  : 	printf("--- srcA = %s\n", srcA);
; 311  : 	printBytes(srcA, 64);
; 312  : 	printf("dstA = %s\n", dstA);
; 313  : 	printBytes(dstA, 32);
; 314  : //*/
; 315  : 	
; 316  : /*
; 317  : 	// Case #1 - no overlap
; 318  : 	memset(dstA, 0x90, 32);
; 319  : 	strcpy(srcA, "Say goodbye to the lazy dog!");	// requires 29 bytes
; 320  : 	printf("\n\n--- srcA = %s\n", srcA);
; 321  : 	printBytes(srcA, 32);
; 322  : 	tmpi = inline_memmove4(dstA, srcA, strlen(srcA)+1 );
; 323  : 	printf("\ndstA @ Address:%08x (tmpi=%08x) = %s\n", dstA, tmpi, dstA);
; 324  : 	printBytes(dstA, 32);
; 325  : 
; 326  : 	// Case #2 - Dst < Src with overlap
; 327  : 	memset(overlap, 0x90, 256);
; 328  : 	ptrDstO = &overlap[0];
; 329  : 	ptrSrcO = &overlap[5];
; 330  : 	strcpy(ptrSrcO, "Say goodbye to the lazy dog that quietly jumped over the brown red fox.");
; 331  : 	printf("\n\n--- srcA @ Address:%08x  = %s, %d\n", ptrSrcO, ptrSrcO,   strlen(ptrSrcO)+1 );
; 332  : 	printBytes(ptrSrcO, 96);
; 333  : 	tmpi = inline_memmove4(ptrDstO, ptrSrcO, strlen(ptrSrcO)+1 );
; 334  : 	printf("\ndstA @ Address:%08x (tmpi=%08x) = %s\n", ptrDstO, tmpi, ptrDstO);
; 335  : 	printBytes(ptrDstO, 96);
; 336  : 
; 337  : 	// Case #3 - Dst > Src with overlap
; 338  : 	memset(overlap, 0x90, 256);
; 339  : 	ptrDstO = &overlap[5];
; 340  : 	ptrSrcO = &overlap[0];
; 341  : 	strcpy(ptrSrcO, "Say hello to the brown red fox that quietly jumped over the lazy dog.");
; 342  : 	printf("\n\n--- srcA @ Address:%08x  = %s, %d\n", ptrSrcO, ptrSrcO, strlen(ptrSrcO)+1);
; 343  : 	printBytes(ptrSrcO, 96);
; 344  : 	tmpi = inline_memmove4(ptrDstO, ptrSrcO, strlen(ptrSrcO)+1 );
; 345  : 	printf("\ndstA @ Address:%08x (tmpi=%08x) = %s\n", ptrDstO, tmpi, ptrDstO);
; 346  : 	printBytes(ptrDstO, 96);
; 347  : //*/
; 348  : 
; 349  : 	exit(0);

  0000e	6a 00		 push	 0
  00010	e8 00 00 00 00	 call	 _exit
$LN2@callInLine:

; 350  : } // callInLineFunctions

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?callInLineFunctions@@YAXXZ ENDP			; callInLineFunctions
END
